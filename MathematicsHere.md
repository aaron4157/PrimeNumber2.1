# Mathematics Lesson
略述專案用到的數學原理。

## 因式分解
算術基本定理：自然數寫成素數的乘積，結果只有一種；1與素數沒有素因數分解式。
引申
* 不可因數分解的，為素數(排除1)
* 一般因數分解式都是素因數分解式的再組合

### 素數表
1. 2是第一個素數
1. 從3開始測試
1. 嘗試素因式分解
1. 找到新的素數就更新列表
1. 加速：選用√a以下的備選素數即可確認因數分解是否存在

生成式算法是基於基本的試除法(trail devision)進行。這個方法可追溯到13世紀，其保證找到所有的素因數，在當今確認素數的算法中是最慢的。

因為素數在自然數中的出現頻率<1/3 (*素數定理*有更精確的推論。事實上，素數在自然數系的出現頻率應趨近於零。)素因式分解的時間是全因數分解(拿出所有小於a的自然數試除)的1/3以下。其它加速算法的方法包括: 檢查尾數、篩去個位數是0,2,4,5,6,8的數字。

缺點：只能確認較小的素數；具體說是當  a>素數表上限<sup>2</sup> 無法使用。

### 互素數(relative prime)
_(a,b)=1_ 的判斷方法，是兩者的素因數不重合。
快速作法：調出a的素因數列表{pa}，嘗試對b進行因數分解。

### 完美數

完美數(perfect number)的因數和恰好整於自己。因數和小於自己的，叫虧數(deficient number)；因數和大於自己的，叫盈數(abundant number)。

所有的素數都是虧數，因為素數的因數為1。

#### 因數表
從素因數分解式可以建構所有因數。若a的素因式為
> a = p1<sup>n1</sup>p2<sup>n2</sup>...pq<sup>nq</sup>

則a的因數c有一般式
> c = p1<sup>m1</sup>p2<sup>m2</sup>...pq<sup>mq</sup>

其中，c所有的指數部分m在{0, 1, ..., n}之中、然後排除a自身。可知a的因數數目有
> (n1 + 1)(n2 + 1)...(nq + 1) - 1

#### 因數和

> σ(a) = a 所有(正)因數c之和

根據因數分解式求算a的全因數和(所有c加上a自身)，其實相對簡單。只要交換和/積順序，所求(乘積之和)即化為等比級數的乘積，可用分治法迭代運算。
使用該技巧可以證明：
> M × (M + 1) / 2

這裡，M是Mersenne素數，形如
> 2<sup>n</sup> - 1

然而逆命題
>(偶) 完美數都是 M × (M + 1) / 2

則很難證明(Euclid-Euler 定理)。

## Goldbach conjecture

> _所有偶數都是兩素數之和_

這個猜想有名的原因在於很難證明。很明顯，0是一個例外，因為0不是其它正數之和；2是一個例外、因為2是第一個素數；那麼，*還有其它的例外嗎？*

以計算機驗算Goldbach猜想並不困難。只要將偶數a以下的素數調出，再測試兩兩之和即可。
減少步驟的作法－以a/2為界，將素數分成兩堆再一一配對。

嘗試驗證弱敘述
> _所有奇數都是三素數之和(排除1、3與5)_

## 產生RSA金鑰的步驟
實際練習，發現難點在求解模反因子
> a × b ≡ 1 Mod m

本例使用窮舉法，即嘗試k=1,2,3,...使得 _a × b = k × m + 1_ ，過程重複上千次都有可能，在這過程中也有**記憶體溢位**的風險，導致計算錯誤。

## 加密/解密RSA密文的步驟
需要計算  a<sup>n</sup> % m 
；直接運算一般字符**一定會**發生記憶體溢位！因此需要以下的數學知識，將大數運算分解成多個小運算。

_使用複合(composite)技巧，改寫函式為物件：Stream具有封裝變數特性(只進不出)；改為注入物件，藉由改變物件狀態、帶出運算結果。_

### 分治法做指數的模運算
 
> a<sup>n</sup> ≡ a1<sup>k</sup>•a<sup>n0</sup> Mod m

自選d對n求商，有 _n = k × d + n0_ 去餘數部分作為新的n再做分解，循環運算得到
> a<sup>n</sup> ≡ aq<sup>nq</sup> •••a0<sup>n0</sup> Mod m

其中
> aq ≡ a(q-1)<sup>d</sup> Mod m;
> a0 ≡ a Mod m;

而序列   nq...n1n0 = n<sub>d</sub>  是n的d進位表示。如此就完成大指數求模數的循序算法。每次迭代的結果，可以先緩衝為陣列、再批次計算模數，進一步減輕記憶體負擔。

本例使用2進位，因為有原生函式支援表示法轉換，而且迭代過程只要計算平方數的模數。

### 利用同餘特性減少計算量
利用以下同餘特性減輕迭代過程中記憶體負擔
> a<sup>2</sup> ≡ (m - a)<sup>2</sup> Mod m

也就是說 當 a > m/2 可以選擇較小的補數(m-a)做計算。暫存變數由 m<sup>2</sup> 減少為 m<sup>2</sup>/4 以下，記憶體負擔減輕2bits。

### 分治算法的效益分析
直接求算大指數a<sup>n</sup>的模，造成記憶體負擔為  n×log<sub>2</sub>a bits以下；使用迭代法分治，造成記憶體負擔為 log<sub>2</sub>n×log<sub>2</sub>a bits以下

## a-PRP 篩法
想知道一個任意給定的 n 是否為素數，任選a為 _(1, n-1)_ 之間的整數，嘗試確認下式
> a<sup>n - 1</sup> ≡ 1 Mod n

根據Fermat小定理，素數滿足此同餘方程式；然而一些合數也可滿足此方程。一般而言，這些數稱為
> _基於a的可能素數(**pr**obable-**p**rime base a)_

對於60位數以下的n，通過此檢定(Fermat素性檢驗)而仍然是合數(偽陽性)**概率<7.2%**；待測數的位數愈大，檢定愈有效。若選擇多個a進行複測，更增加n是素數的信度(僅有少數合數無法透過複檢確認)。

僅使用初等算法，PRP篩法幾乎無法執行的：若使用內建的模運算%搭配double暫存變數，此法只能判斷66以下的2-PRP(<= 61)；加入分治法，也只能判斷9923以下的2-PRP；在這種情況下，自動化的試除法還略勝一籌呢。只要解決大數求模數的技術問題，PRP篩法仍然是尋找大素數的基礎做法，許多商業軟體、甚至Java的BigInteger類都有實作。


## 友站連結
關於素數的一切都在這裡了
[PrimePages](https://primes.utm.edu/)
