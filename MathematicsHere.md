# Mathematics Lesson
略述專案用到的數學原理。

## 因式分解
算術基本定理：自然數寫成素數的乘積，結果只有一種；1與素數沒有素因數分解式。
引申
* 不可因數分解的，為素數(排除1)
* 一般因數分解式都是素因數分解式的再組合

### 素數表
1. 2是第一個素數
1. 從3開始測試
1. 嘗試素因式分解
1. 找到新的素數就更新列表
1. 技巧：選用√a以下的備選素數即可確認因數分解是否存在

相較於一一確認的做法(確認所有b<a是否有b|a)，生成式算法較快速。尤其是對於一般應用，查表即知是否為素數。
因為素數在自然數中的出現頻率<**1/3** (*素數定理*有更精確的推論)此算法的花費時間也是一般算法的1/3以下(其實根據*素數定理*生成式算法在尋找大素數的效率還要更高)。
缺點：無法判斷隨機給定的大數；具體說是當  a>素數表上限<sup>2</sup> 無法使用。
建議：多做前置工作，預先準備足夠大的素數表。

### 互素數(relative prime)
_(a,b)=1_ 的判斷方法，是兩者的素因數不重合。
快速作法：調出a的素因數列表{pa}，嘗試對b進行因數分解。

### 完美數

#### 因數表
從素因數分解式可以建構所有因數分解式。若a的素因數式為
> a = p1<sup>n1</sup>p2<sup>n2</sup>...pq<sup>nq</sup>

則a的因數c有一般式
> c = p1<sup>m1</sup>p2<sup>m2</sup>...pq<sup>mq</sup>

其中，c所有的指數部分m在{0, 1, ..., n}之中、然後排除a自身。可知a的因數數目有
> (n1 + 1)(n2 + 1)...(nq + 1) - 1

#### 因數和
根據因數分解式求算a的全因數和(所有c加上a自身)，其實相對簡單。只要交換和/積順序，所求(乘積之和)即化為等比級數的乘積，可用分治法迭代運算。
使用該技巧可以證明：
> 2<sup>n</sup> × Mersenne素數 是完美數

然而逆命題
> 完美數都是 2<sup>n</sup> × Mersenne素數

則很難證明。

## Goldbach conjecture

> _所有偶數都是兩素數之和_

這個猜想有名的原因在於很難證明。很明顯，0是一個例外，因為0不是其它正數之和；2是一個例外、因為2是第一個素數；那麼，*還有其它的例外嗎？*
以計算機驗算Goldbach猜想並不困難。只要將偶數a以下的素數調出，再測試兩兩之和即可。
減少步驟的作法－以a/2為界，將素數分成兩堆再一一配對。
嘗試驗證弱敘述
> _所有奇數都是三素數之和(排除1、3與5)_

## 產生RSA金鑰的步驟
實際練習，發現難點在求解模反因子
> a × b ≡ 1 Mod m

本例使用窮舉法，即嘗試k=1,2,3,...使得 _a × b = k × m + 1_ ，過程重複上千次都有可能，在這過程中也有**記憶體溢位**的風險，導致計算錯誤。

## 加密/解密RSA密文的步驟
需要計算  a<sup>n</sup> % m 
；直接運算一般字符**一定會**發生記憶體溢位！因此需要以下的數學知識，將大數運算分解成多個小運算。
_使用複合(composite)技巧，改寫函式為物件：Stream具有封裝變數特性(只進不出)；改為注入物件，藉由改變物件狀態、帶出運算結果。_

### 分治法做指數的模運算
 
> a<sup>n</sup> ≡ a1<sup>k</sup>•a<sup>n0</sup> Mod m

自選d對n求商，有 _n = k × d + n0_ 去餘數部分作為新的n再做分解，循環運算得到
> a<sup>n</sup> ≡ aq<sup>nq</sup> •••a0<sup>n0</sup> Mod m

其中
> aq ≡ a(q-1)<sup>d</sup> Mod m;
> a0 ≡ a Mod m;

而序列   nq...n1n0 = n<sub>d</sub>  是n的d進位表示。如此就完成大指數求模數的循序算法。
本例使用2進位，因為有原生函式支援表示法轉換，而且迭代過程只要計算平方數的模數。

### 利用同餘特性減少計算量
利用以下同餘特性減輕迭代過程中記憶體負擔
> a<sup>2</sup> ≡ (m - a)<sup>2</sup> Mod m

也就是說 當 a > m/2 可以選擇較小的補數(m-a)做計算。暫存變數由 m<sup>2</sup> 減少為 m<sup>2</sup>/4 以下，記憶體負擔減輕2bits。

### 分治算法的效益分析
直接求算大指數a<sup>n</sup>的模，造成記憶體負擔為  n×log<sub>2</sub>a bits以下
；使用迭代法分治，造成記憶體負擔為 log<sub>2</sub>n×log<sub>2</sub>a bits以下

## a-PRP 篩法
想知道一個任意給定的 n 是否為素數，任選a為 _(1, n-1)_ 之間的整數，嘗試確認下式
> a<sup>n - 1</sup> ≡ 1 Mod n

根據Fermat小定理，素數滿足此同餘方程式；然而一些合數也可滿足此方程。一般而言，這些數稱為
> _基於a的可能素數(**pr**obable-**p**rime base a)_

對於60位數以下的n，通過此檢定(Fermat合數檢驗)而仍然是合數(偽陽性)**概率<7.2%**；待測數的位數愈大，檢定愈有效。若選擇多個a進行複測，更增加n是素數的信度。
此算法是尋找大素數的流行做法。也可應用前文提到的分治法進行計算。

## 友站連結
關於素數的一切都在這裡了
[PrimePages](https://primes.utm.edu/)
