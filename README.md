# PrimeNumber2.1
第二代的演算法具有服務架構 [數學課由此。慎入](MathematicsHere.md)

* 資料封裝為Java bean 物件
* 使用範例在demo包、功能在maximal包
* OptimusPrime 是資料應對物件(DAO)
* Rattrap 物件打包資料為 Java bean
* Rhinox 物件負責文字訊息加密與解密
* 優化:素數數列預先載入cache，視需要分派複本
* 預設支援10,000,000,000以內的自然數因數分解。有需要請自行更改上限upper=√(想要的自然數上限) 產生新的檔案
* PS尋找另外兩個內部物件 dinobot 與 cheetor

### 新版特色
* 引入虛擬資料表的概念。素數數列作為核心有持久化(persistence)，其它"欄位"推算得到。
* 引入依賴注入(DI)的作法，將數據與算法完全分開
* 驗算(verify) 強版本Goldbach conjecture，為所有偶數計算素數對
* 非對稱加密/解密示範
* 引入Java SE8 的串流(Stream)類別

### 基於素數表各種算法
前代嘗試過動態的計算方式。後來發現，多做些前置工作，建立大型的質數參考表，比較方便。這是以(靜態)空間換取時間。

### 關於RSA加密(RSA encryption)
先說感想。RSA的加密/解密運算占用大量記憶體。即使持有金鑰，也很難在小程式使用。自製實用的RSA加密/解密機已經很困難。而自行生產金鑰、甚至破譯金鑰，對於機器計算力的需求極高、這種技術的持有者，鎖定目標通常都很大；平民的秘密應該不會引起他們的興趣。
例如、256<sup>128</sup> 就可以塞爆**double**變數的記憶體，中文碼(>13,000)加密需要其它技術支援。
本例使用unicode編碼作為文字/數字對應，因為這是Java原生的字符表，JVM支援**char**↔**int**原生轉換。受限於軟體的算力，金鑰只有一只、而且不大，只能加密/解密拉丁文字。
> 預設範例： 將訊息
"Hello world!!" 加密成
"ÖúggßǗ[ßōgũÿÿ" 再解密。任何跟Rhinox物件取得公鑰的人，都可以發送加密訊息給他。

實際應用的RSA：
* 通訊雙方交換公鑰，進行雙向溝通
*  金鑰的數字佔位2048 bits以上
* 對字串而非字元加密
* 經常更換金鑰 ex一段文字切成3組、以3只金鑰加密
